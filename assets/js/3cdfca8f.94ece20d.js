"use strict";(globalThis.webpackChunkapache_website_template=globalThis.webpackChunkapache_website_template||[]).push([[185],{5756(e,t,n){n.d(t,{R:()=>r,x:()=>o});var a=n(9471);const i={},s=a.createContext(i);function r(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}},6279(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"basics","title":"basics","description":"\x3c!--","source":"@site/docs/basics.md","sourceDirName":".","slug":"/basics","permalink":"/docs/basics","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/otava-website/tree/master/docs/basics.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"contribute","permalink":"/docs/contribute"},"next":{"title":"Graphite","permalink":"/docs/graphite"}}');var i=n(2615),s=n(5756);const r={},o="Basics",c={},l=[{value:"Listing Available Tests",id:"listing-available-tests",level:2},{value:"Listing Available Metrics for Tests",id:"listing-available-metrics-for-tests",level:2},{value:"Example",id:"example",level:3},{value:"Finding Change Points",id:"finding-change-points",level:2},{value:"Example",id:"example-1",level:3},{value:"Avoiding test definition duplication",id:"avoiding-test-definition-duplication",level:2},{value:"Validating Performance of a Feature Branch",id:"validating-performance-of-a-feature-branch",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"basics",children:"Basics"})}),"\n",(0,i.jsx)(t.h2,{id:"listing-available-tests",children:"Listing Available Tests"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"otava list-groups\n"})}),"\n",(0,i.jsx)(t.p,{children:"Lists all available test groups - high-level categories of tests."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"otava list-tests [group name]\n"})}),"\n",(0,i.jsx)(t.p,{children:"Lists all tests or the tests within a given group, if the group name is provided."}),"\n",(0,i.jsx)(t.h2,{id:"listing-available-metrics-for-tests",children:"Listing Available Metrics for Tests"}),"\n",(0,i.jsx)(t.p,{children:"To list all available metrics defined for the test:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"otava list-metrics <test>\n"})}),"\n",(0,i.jsx)(t.h3,{id:"example",children:"Example"}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["See ",(0,i.jsx)(t.a,{href:"https://github.com/apache/otava/tree/master/examples/csv/config/otava.yaml",children:"otava.yaml"})," for the full example configuration."]})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"$ otava list-metrics local.sample\nmetric1\nmetric2\n"})}),"\n",(0,i.jsx)(t.h2,{id:"finding-change-points",children:"Finding Change Points"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"otava analyze <test>...\notava analyze <group>...\n"})}),"\n",(0,i.jsx)(t.p,{children:'This command prints interesting results of all\nruns of the test and a list of change-points.\nA change-point is a moment when a metric value starts to differ significantly\nfrom the values of the earlier runs and when the difference\nis persistent and statistically significant that it is unlikely to happen by chance.\nOtava calculates the probability (P-value) that the change point was caused\nby chance - the closer to zero, the more "sure" it is about the regression or\nperformance improvement. The smaller is the actual magnitude of the change,\nthe more data points are needed to confirm the change, therefore Otava may\nnot notice the regression immediately after the first run that regressed.\nHowever, it will eventually identify the specific commit that caused the regression,\nas it analyzes the history of changes rather than just the HEAD of a branch.'}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"analyze"})," command accepts multiple tests or test groups.\nThe results are simply concatenated."]}),"\n",(0,i.jsx)(t.h3,{id:"example-1",children:"Example"}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["See ",(0,i.jsx)(t.a,{href:"https://github.com/apache/otava/tree/master/examples/csv/otava.yaml",children:"otava.yaml"})," for the full\nexample configuration and ",(0,i.jsx)(t.a,{href:"https://github.com/apache/otava/tree/master/examples/csv/data/local_samples.csv",children:"local_samples.csv"}),"\nfor the data."]})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"$ otava analyze local.sample --since=2024-01-01\nINFO: Computing change points for test sample.csv...\nsample:\ntime                         metric1    metric2\n-------------------------  ---------  ---------\n2021-01-01 02:00:00 +0000     154023      10.43\n2021-01-02 02:00:00 +0000     138455      10.23\n2021-01-03 02:00:00 +0000     143112      10.29\n2021-01-04 02:00:00 +0000     149190      10.91\n2021-01-05 02:00:00 +0000     132098      10.34\n2021-01-06 02:00:00 +0000     151344      10.69\n                                      \xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\n                                         -12.9%\n                                      \xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\n2021-01-07 02:00:00 +0000     155145       9.23\n2021-01-08 02:00:00 +0000     148889       9.11\n2021-01-09 02:00:00 +0000     149466       9.13\n2021-01-10 02:00:00 +0000     148209       9.03\n"})}),"\n",(0,i.jsx)(t.h2,{id:"avoiding-test-definition-duplication",children:"Avoiding test definition duplication"}),"\n",(0,i.jsx)(t.p,{children:"You may find that your test definitions are very similar to each other,  e.g. they all have the same metrics. Instead\nof copy-pasting the definitions  you can use templating capability built-in otava to define the common bits of configs\nseparately."}),"\n",(0,i.jsxs)(t.p,{children:["First, extract the common pieces to the ",(0,i.jsx)(t.code,{children:"templates"})," section:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"templates:\n  common-metrics:\n    throughput:\n      suffix: client.throughput\n    response-time:\n      suffix: client.p50\n      direction: -1    # lower is better\n    cpu-load:\n      suffix: server.cpu\n      direction: -1    # lower is better\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Next you can recall a template in the ",(0,i.jsx)(t.code,{children:"inherit"})," property of the test:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"my-product.test-1:\n  type: graphite\n  tags: [perf-test, daily, my-product, test-1]\n  prefix: performance-tests.daily.my-product.test-1\n  inherit: common-metrics\nmy-product.test-2:\n  type: graphite\n  tags: [perf-test, daily, my-product, test-2]\n  prefix: performance-tests.daily.my-product.test-2\n  inherit: common-metrics\n"})}),"\n",(0,i.jsx)(t.p,{children:"You can inherit more than one template."}),"\n",(0,i.jsx)(t.h2,{id:"validating-performance-of-a-feature-branch",children:"Validating Performance of a Feature Branch"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"otava regressions"})," command can work with feature branches."]}),"\n",(0,i.jsxs)(t.p,{children:["First you need to tell Otava how to fetch the data of the tests run against a feature branch.\nThe ",(0,i.jsx)(t.code,{children:"prefix"})," property of the graphite test definition accepts ",(0,i.jsx)(t.code,{children:"%{BRANCH}"})," variable,\nwhich is substituted at the data import time by the branch name passed to ",(0,i.jsx)(t.code,{children:"--branch"}),"\ncommand argument. Alternatively, if the prefix for the main branch of your product is different\nfrom the prefix used for feature branches, you can define an additional ",(0,i.jsx)(t.code,{children:"branch_prefix"})," property."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"my-product.test-1:\n  type: graphite\n  tags: [perf-test, daily, my-product, test-1]\n  prefix: performance-tests.daily.%{BRANCH}.my-product.test-1\n  inherit: common-metrics\n\nmy-product.test-2:\n  type: graphite\n  tags: [perf-test, daily, my-product, test-2]\n  prefix: performance-tests.daily.master.my-product.test-2\n  branch_prefix: performance-tests.feature.%{BRANCH}.my-product.test-2\n  inherit: common-metrics\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now you can verify if correct data are imported by running\n",(0,i.jsx)(t.code,{children:"otava analyze <test> --branch <branch>"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"--branch"})," argument also works with ",(0,i.jsx)(t.code,{children:"otava regressions"}),". In this case a comparison will be made\nbetween the tail of the specified branch and the tail of the main branch (or a point of the\nmain branch specified by one of the ",(0,i.jsx)(t.code,{children:"--since"})," selectors)."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"$ otava regressions <test or group> --branch <branch>\n$ otava regressions <test or group> --branch <branch> --since <date>\n$ otava regressions <test or group> --branch <branch> --since-version <version>\n$ otava regressions <test or group> --branch <branch> --since-commit <commit>\n"})}),"\n",(0,i.jsxs)(t.p,{children:["When comparing two branches, you generally want to compare the tails of both test histories, and\nspecifically a stable sequence from the end that doesn't contain any changes in itself.\nTo ignore the older test results, and compare\nonly the last few points on the branch with the tail of the main branch,\nuse the ",(0,i.jsx)(t.code,{children:"--last <n>"})," selector. E.g. to check regressions on the last run of the tests\non the feature branch:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"$ otava regressions <test or group> --branch <branch> --last 1\n"})}),"\n",(0,i.jsx)(t.p,{children:"Please beware that performance validation based on a single data point is quite weak\nand Otava might miss a regression if the point is not too much different from\nthe baseline. However, accuracy improves as more data points accumulate, and it is\na normal way of using Otava to just merge a feature and then revert if it is\nflagged later."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);